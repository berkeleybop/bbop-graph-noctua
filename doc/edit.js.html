<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: edit.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: edit.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/** 
 * Purpose: Noctua editing operations ove a bbop-graph base.
 * 
 * The base pieces are just subclasses of their analogs in bbop-graph.
 * 
 * @see module:bbop-graph
 * @module bbop-graph-noctua
 */

var us = require(&#x27;underscore&#x27;);
var each = us.each;
var keys = us.keys;
var bbop = require(&#x27;bbop-core&#x27;);
var bbop_model = require(&#x27;bbop-graph&#x27;);
var class_expression = require(&#x27;class-expression&#x27;);

///
/// New stuff: annotations.
///

/**
 * Edit annotations.
 * Everything can take annotations.
 * 
 * This structure of the raw key-value set has been updated in the
 * wire protocol. It now looks like:
 * 
 * : {&quot;key&quot;: &quot;contributor&quot;, &quot;value&quot;: &quot;GOC:kltm&quot; }
 * 
 * or:
 * 
 * : {&quot;key&quot;: &quot;contributor&quot;, &quot;value&quot;: &quot;GOC:kltm&quot;, &quot;value-type&quot;:&quot;foo&quot;}
 * 
 * @constructor
 * @param {Object} kv_set - (optional) a set of keys and values; a simple object
 * @returns {this} new instance
 */
function annotation(kv_set){
    this._id = bbop.uuid();
    
    this._properties = {};
    
    if( kv_set &amp;amp;&amp;amp; bbop.what_is(kv_set) == &#x27;object&#x27; ){
	
	// Attempt to convert
	if( kv_set[&#x27;key&#x27;] &amp;amp;&amp;amp; kv_set[&#x27;value&#x27;] ){
	    var key = kv_set[&#x27;key&#x27;];
	    var val = kv_set[&#x27;value&#x27;];
	    // var adj_set = {};
	    // adj_set[key] = val;
	    // Silently pass in value-type if there.
	    this._properties = bbop.clone(kv_set);
	}else{
	    // TODO: Replace this at some point with the logger.
	    console.log(&#x27;bad annotation k/v set: &#x27;, kv_set);
	}
    }
}

/**
 * The unique id of this annotation.
 *
 * @memberOf annotation
 * @returns {String} string
 */
annotation.prototype.id = function(){
    return this._id;
};

/**
 * Add/modify a property by key and value (and maybe value_type).
 *
 * @param {String} key - string
 * @param {String} value - (optional) string
 * @param {String} value_type - (optional) string
 * @returns {String|null} returns property is key
 */
annotation.prototype.annotation = function(key, value, value_type){

    var anchor = this;
    var ret = null;

    // Set if the key and value are there.
    if( key ){
	if( typeof(value) !== &#x27;undefined&#x27; ){
	    anchor._properties[&#x27;key&#x27;] = key;
	    anchor._properties[&#x27;value&#x27;] = value;

	    // Add or get rid of value type depending.
	    if( typeof(value_type) == &#x27;undefined&#x27; ){
		delete anchor._properties[&#x27;value-type&#x27;];
	    }else{
		anchor._properties[&#x27;value-type&#x27;] = value_type;
	    }
	}
    }
    ret = anchor._properties;

    return ret;
};

/**
 * Get/set annotation&#x27;s key.
 *
 * @param {String} key - (optional) string
 * @returns {String|null} returns string of annotation
 */
annotation.prototype.key = function(key){
    var anchor = this;
    if( key ){ anchor._properties[&#x27;key&#x27;] = key; }
    return anchor._properties[&#x27;key&#x27;];
};

/**
 * Get/set annotation&#x27;s value.
 *
 * @param {String} value - (optional) string
 * @returns {String|null} returns string of annotation
 */
annotation.prototype.value = function(value){
    var anchor = this;
    if( value ){ anchor._properties[&#x27;value&#x27;] = value; }
    return anchor._properties[&#x27;value&#x27;];
};

/**
 * Get/set annotation&#x27;s value-type.
 *
 * @param {String} value_type - (optional) string
 * @returns {String|null} returns string of annotation
 */
annotation.prototype.value_type = function(value_type){
    var anchor = this;
    if( value_type ){ anchor._properties[&#x27;value-type&#x27;] = value_type; }
    return anchor._properties[&#x27;value-type&#x27;];
};

/**
 * Delete a property by key.
 *
 * @param {String} key - string
 * @returns {Boolean} true if not empty
 */
annotation.prototype.delete = function(){

    var anchor = this;
    var ret = false;

    if( ! us.isEmpty(anchor._properties) ){
	anchor._properties = {}; // nuke
	ret = true;
    }

    return ret;
};

/**
 * Clone an annotation.
 *
 * @returns {annotation} a fresh annotation for no shared structure
 */
annotation.prototype.clone = function(){
    var anchor = this;

    // Copy most of the data structure.
    var a = {};
    if( anchor.key() ){ a[&#x27;key&#x27;] = anchor.key(); }
    if( anchor.value() ){ a[&#x27;value&#x27;] = anchor.value(); }
    if( anchor.value_type() ){ a[&#x27;value-type&#x27;] = anchor.value_type(); }

    var new_ann = new annotation(a);

    // Copy ID as well.
    new_ann._id = anchor._id;
    
    return new_ann;
};

///
/// Generic internal annotation operations; dynamically attached to
/// graph, node, and edge.
///

/**
 * Get/set annotation list.
 *
 * @name annotations
 * @function
 * @param {Array} in_anns - (optional) list of annotations to clobber current list
 * @returns {Array} list of all annotations
 */
function _annotations(in_anns){
    if( us.isArray(in_anns) ){
	this._annotations = in_anns;
    }
    return this._annotations;
}

/**
 * Add annotation.
 *
 * @name add_annotation
 * @function
 * @param {annotation} in_ann - annotation to add
 * @returns {Array} list of all annotations
 */
function _add_annotation(in_ann){
    if( ! us.isArray(in_ann) ){
	this._annotations.push(in_ann);
    }
    return this._annotations;
}

/**
 * Get a sublist of annotation using the filter function. The filter
 * function take a single annotation as an argument, and adds to the
 * return list if it evaluates to true.
 *
 * @name get_annotations_by_filter
 * @function
 * @param {Function} filter - function described above
 * @returns {Array} list of passing annotations
 */
function _get_annotations_by_filter(filter){

    var anchor = this;
    var ret = [];
    each(anchor._annotations, function(ann){
	var res = filter(ann);
	if( res &amp;amp;&amp;amp; res == true ){
	    ret.push(ann);
	}
    });
    return ret;
}

/**
 * Get sublist of annotations with a certain key.
 *
 * @name get_annotations_by_key
 * @function
 * @param {String} key - key to look for.
 * @returns {Array} list of list of annotations with that key
 */
function _get_annotations_by_key(key){

    var anchor = this;
    var ret = [];
    each(anchor._annotations, function(ann){
	if( ann.key() == key ){
	    ret.push(ann);
	}
    });
    return ret;
}

/**
 * Get sublist of annotations with a certain ID.
 *
 * @name get_annotations_by_id
 * @function
 * @param {String} aid - annotation ID to look for
 * @returns {Array} list of list of annotations with that ID
 */
function _get_annotation_by_id(aid){

    var anchor = this;
    var ret = null;
    each(anchor._annotations, function(ann){
	if( ann.id() == aid ){
	    ret = ann;
	}
    });
    return ret;
}

///
/// Generic internal evidence (reference individuals) operations;
/// dynamically attached to node and edge.
///

/**
 * Get/set referenced individual list.
 *
 * Also, changes type to &quot;referenced&quot; from (probably) node.
 *
 * @name referenced_individuals
 * @function
 * @param {Array} indivs - (optional) list of {node} to clobber current list
 * @returns {Array} list of all referenced individuals
 */
function _referenced_individuals(indivs){

    if( us.isArray(indivs) ){

	// Convert type.
	each(indivs, function(ind){
	    ind.type(&#x27;referenced&#x27;);
	});

	// Not copies, so add by replacement.
	this._referenced_individuals = indivs;
    }
    return this._referenced_individuals;
}

/**
 * Add referenced individual.
 *
 * Also, changes type to &quot;referenced&quot; from (probably) node.
 *
 * @name add_referenced_individual
 * @function
 * @param {annotation} indiv - individual to add
 * @returns {Array} list of all individuals
 */
function _add_referenced_individual(indiv){
    if( ! us.isArray(indiv) ){	
	indiv.type(&#x27;referenced&#x27;);
	this._referenced_individuals.push(indiv);
    }
    return this._referenced_individuals;
}

/**
 * Get a sublist of referenced individuals using the filter
 * function. The filter function take a single individual as an
 * argument, and adds to the return list if it evaluates to true.
 *
 * @name get_referenced_individuals_by_filter
 * @function
 * @param {Function} filter - function described above
 * @returns {Array} list of passing individuals
 */
function _get_referenced_individuals_by_filter(filter){
    var anchor = this;

    var ret = [];
    each(anchor._referenced_individuals, function(ind){
	var res = filter(ind);
	if( res &amp;amp;&amp;amp; res == true ){
	    ret.push(ind);
	}
    });

    return ret;
}

/**
 * Get sublist of referenced_individuals with a certain ID.
 *
 * @name get_referenced_individual_by_id
 * @function
 * @param {String} iid - referenced_individual ID to look for
 * @returns {Array} list of referenced_individuals with that ID
 */
function _get_referenced_individual_by_id(iid){
    var anchor = this;

    var ret = null;
    each(anchor._referenced_individuals, function(ind){
	if( ind.id() == iid ){
	    ret = ind;
	}
    });

    return ret;
}

/**
 * Returns a list with the following structure:
 *
 * : [ { id: &amp;lt;ID&gt;,
 * :     class_expressions: [{class_expression}, ...],
 * :     anntations: [{annotation}, ...] },
 * :   ...
 * : ]
 *
 * Each top-level element in the list represents the core information
 * of a single referenced individual for a node or edge in this model.
 *
 * Keep in mind that this may be most useful in the GO Noctua use case
 * where evidence is uniformly modeled as (a) referenced
 * individual(s), where the class(es) are evidence and the annotations
 * keep things such as source (e.g. PMID), etc.
 *
 * @name get_referenced_individual_profiles
 * @function
 * @returns {Array} list of referenced_individual information.
 */
function _get_referenced_individual_profiles(){
    var anchor = this;

    var ret = [];
    each(anchor.referenced_individuals(), function(ind){

	// Base.
	var prof = {
	    id: null,
	    class_expressions: [],
	    annotations: []
	}

	// Referenced instance ID.
	prof.id = ind.id();

	// Collect class expressions and annotations.
	each(ind.types(), function(ce){
	    prof.class_expressions.push(ce);
	});
	each(ind.annotations(), function(ann){
	    prof.annotations.push(ann);
	});

	//
	ret.push(prof);
    });

    return ret;
}

/**
 * Returns a list with the following structure:
 *
 * : [ { id: &amp;lt;ID&gt;,
 * :     cls: &amp;lt;ID&gt;,
 * :     source: &amp;lt;STRING&gt;,
 * :     date: &amp;lt;STRING&gt;,
 * :     etc
 * :   },
 * :   ...
 * : ]
 *
 * Each top-level element in the list represents the core information
 * in a simple (GO-style) element. This is essentially a distilled
 * version of get_referenced_individual_profiles for cases where that
 * is modelling simple piece of evidence (single non-nested class
 * expression and a set know list of annotations).
 *
 * @name get_basic_evidence
 * @function
 * @param {Array} annotation_ids - list of strings that identify the annotation keys that will be captured--
 * @returns {Array} list of referenced_individual simple evidence information.
 */
function _get_basic_evidence(annotation_ids){
    var anchor = this;

    var ret = [];

    // Get hash of the annotation keys present.
    var test = us.object(us.map(annotation_ids,
				function(e){ return [e, true]}));

    each(anchor.get_referenced_individual_profiles(), function(cmplx_prof){
	//console.log(cmplx_prof);

	// Only add conformant referenced individuals.
	if( cmplx_prof.id &amp;amp;&amp;amp; ! us.isEmpty(cmplx_prof.class_expressions) ){

	    // Base.
	    //console.log(cmplx_prof.class_expressions);
	    var basic_prof = {
		id: cmplx_prof.id,
		cls: cmplx_prof.class_expressions[0].to_string()
	    };
	    
	    // Match and clobber.
	    each(cmplx_prof.annotations, function(ann){
		//console.log(ann);
		if( test[ann.key()] ){
		    basic_prof[ann.key()] = ann.value();
		}
	    });

	    //console.log(basic_prof);
	    ret.push(basic_prof);
	}
	
    });

    return ret;
}

///
/// Next, get some subclasses working for the core triumvirate: graph,
/// node, edge. Start with graph.
///

var bbop_graph = bbop_model.graph;

/**
 * Sublcass of bbop-graph for use with Noctua ideas and concepts.
 *
 * @constructor
 * @see module:bbop-graph
 * @alias graph
 * @param {String} new_id - (optional) new id; otherwise new unique generated
 * @returns {this}
 */
function noctua_graph(new_id){
    bbop_graph.call(this);
    this._is_a = &#x27;bbop-graph-noctua.graph&#x27;;

    // Deal with id.
    if( new_id ){ bbop_graph.id(new_id); }

    // The old edit core.
    this.core = {
	&#x27;edges&#x27;: {}, // map of id to edit_edge - edges not completely anonymous
	&#x27;node_order&#x27;: [], // initial table order on redraws
	&#x27;node2elt&#x27;: {}, // map of id to physical object id
	&#x27;elt2node&#x27;: {},  // map of physical object id to id
	// Remeber that edge ids and elts ids are the same, so no map
	// is needed.
	&#x27;edge2connector&#x27;: {}, // map of edge id to virtual connector id
	&#x27;connector2edge&#x27;: {}  // map of virtual connector id to edge id 
    };

    this._annotations = [];
    //this._referenced_individuals = []; // not for graph yet, or maybe ever
};
bbop.extend(noctua_graph, bbop_graph);

/**
 * Create an edge for use in internal operations.
 *
 * @param {string} subject - node id string or node
 * @param {string} object - node id string or node
 * @param {string} predicate - (optional) a user-friendly description of the node
 * @returns {edge} bbop model edge
 */
noctua_graph.prototype.create_edge = function(subject, object, predicate){
    return new noctua_edge(subject, object, predicate);
};

/**
 * Create a node for use in internal operations.
 *
 * @param {string} id - a unique id for the node
 * @param {string} label - (optional) a user-friendly description of the node
 * @param {Array} types - (optional) list of types to pre-load
 * @returns {node} new bbop model node
 */
noctua_graph.prototype.create_node = function(id, label, types){
    return new noctua_node(id, label, types);
};

/**
 * Create a graph for use in internal operations.
 *
 * @returns {graph} bbop model graph
 */
noctua_graph.prototype.create_graph = function(){
    return new noctua_graph();
};

/**
 * Add an ID to the graph.
 *
 * Use .id() instead.
 *
 * @deprecated
 * @see module:bbop-graph#id
 * @param {String} id - string
 * @returns {String} string
 */
noctua_graph.prototype.add_id = function(id){
    return this.id(id);
};

/**
 * Get the ID from the graph.
 *
 * Use .id() instead.
 *
 * @deprecated
 * @see module:bbop-graph#id
 * @returns {String} string
 */
noctua_graph.prototype.get_id = function(){
    return this.id();
};

/**
 * Get the ID from the graph.
 *
 * @param {node} enode - noctua node
 * @returns {Boolean} true on new node
 */
noctua_graph.prototype.add_node = function(enode){
    // Super call: add it to the general graph.
    bbop_graph.prototype.add_node.call(this, enode);

    var ret = false;
    
    // Add/update node.
    var enid = enode.id();
    //this.core[&#x27;nodes&#x27;][enid] = enode; // add to nodes

    // Only create a new elt ID and order if one isn&#x27;t already in
    // there (or reuse things to keep GUI working smoothly).
    var elt_id = this.core[&#x27;node2elt&#x27;][enid];
    if( ! elt_id ){ // first time
	this.core[&#x27;node_order&#x27;].unshift(enid); // add to default order
	elt_id = bbop.uuid(); // generate the elt id we&#x27;ll use from now on
	this.core[&#x27;node2elt&#x27;][enid] = elt_id; // map it
	this.core[&#x27;elt2node&#x27;][elt_id] = enid; // map it	
	ret = true;
    }

    return ret;
};

/**
 * Add a node into the graph modeled from the the JSON-LD lite model.
 * Creates or adds types and annotations as necessary.
 *
 * @param {Object} indv - hash rep of graph individual from Minerva response?
 * @returns {node|null} 
 */
noctua_graph.prototype.add_node_from_individual = function(indv){
    var anchor = this;

    var new_node = null;

    // Add individual to edit core if properly structured.
    var iid = indv[&#x27;id&#x27;];
    if( iid ){
	//var nn = new bbop.model.node(indv[&#x27;id&#x27;]);
	//var meta = {};
	//ll(&#x27;indv&#x27;);
	
	// See if there is type info that we want to add.
	// Create the node.
	var itypes = indv[&#x27;type&#x27;] || [];
	new_node = anchor.create_node(iid, null, itypes);

	// See if there is type info that we want to add.
	var ianns = indv[&#x27;annotations&#x27;] || [];
	if( us.isArray(ianns) ){
	    // Add the annotations individually.
	    each(ianns, function(ann_kv_set){
		var na = new annotation(ann_kv_set);
		new_node.add_annotation(na);
	    });
	}
	
	anchor.add_node(new_node);
    }
    
    return new_node;
};

/**
 * Return the &quot;table&quot; order of the nodes.
 *
 * @returns {Array} node order by id?
 */
noctua_graph.prototype.edit_node_order = function(){
    return this.core[&#x27;node_order&#x27;] || [];
};

/**
 * Return a node&#x27;s element id.
 *
 * @returns {String|null} node element id
 */
noctua_graph.prototype.get_node_elt_id = function(enid){
    return this.core[&#x27;node2elt&#x27;][enid] || null;
};

/**
 * Return a node by its element id.
 *
 * @returns {node|null} node
 */
noctua_graph.prototype.get_node_by_elt_id = function(elt_id){
    var ret = null;
    var enid = this.core[&#x27;elt2node&#x27;][elt_id] || null;
    if( enid ){
	ret = this.get_node(enid) || null;
    }
    return ret;
};

/**
 * Return a node by its corresponding Minerva JSON rep individual.
 *
 * @returns {node|null} node
 */
noctua_graph.prototype.get_node_by_individual = function(indv){
    var anchor = this;

    var ret = null;

    // Get node from graph if individual rep is properly structured.
    var iid = indv[&#x27;id&#x27;];
    if( iid ){	
	ret = this.get_node(iid) || null;
    }
    
    return ret;
};

/**
 * Return a hash of node ids to nodes.
 * Real, not a copy.
 *
 * @see module:bbop-graph#all_nodes
 * @returns {Object} node ids to nodes
 */
noctua_graph.prototype.get_nodes = function(){
    return this._nodes || {};
};

/**
 * Remove a node from the graph.
 *
 * @param {String} node_id - the id for a node
 * @param {Boolean} clean_p - (optional) remove all edges connects to node (default false)
 * @returns {Boolean} true if node found and destroyed
 */
noctua_graph.prototype.remove_node = function(node_id, clean_p){
    var anchor = this;

    var ret = false;
    var enode = anchor.get_node(node_id);
    if( enode ){
	ret = true;

	///
	/// First, remove all subclass decorations.
	///

	// Also remove the node from the order list.
	// TODO: Is this a dumb scan?
	var ni = this.core[&#x27;node_order&#x27;].indexOf(node_id);
	if( ni != -1 ){
	    this.core[&#x27;node_order&#x27;].splice(ni, 1);
	}

	// Clean the maps.
	var elt_id = this.core[&#x27;node2elt&#x27;][node_id];
	delete this.core[&#x27;node2elt&#x27;][node_id];
	delete this.core[&#x27;elt2node&#x27;][elt_id];

	///
	/// We want to maintain superclass compatibility.
	/// 

	// Finally, remove the node itself.
	bbop_graph.prototype.remove_node.call(this, node_id, clean_p);
    }

    return ret;
};

/**
 * Add an edge to the graph. Remember that edges are no anonymous
 * edges here.
 *
 * @param {edge} eedge - a bbop-graph-noctua#edge
 */
noctua_graph.prototype.add_edge = function(eedge){

    // Super.
    bbop_graph.prototype.add_edge.call(this, eedge);

    // Sub.
   var eeid = eedge.id();
   if( ! eeid ){ throw new Error(&#x27;edge not of bbop-graph-noctua&#x27;); }
   this.core[&#x27;edges&#x27;][eeid] = eedge;
};

/**
 * Add an edge to the graph using a &quot;fact&quot; as the seed.
 * Creates and adds annotations as necessary.
 *
 * @param {} fact - JSON structure representing a fact
 * @returns {edge} newly created edge
 */
noctua_graph.prototype.add_edge_from_fact = function(fact){
    var anchor = this;

    var new_edge = null;
    
    // Add individual to edit core if properly structured.
    var sid = fact[&#x27;subject&#x27;];
    var oid = fact[&#x27;object&#x27;];
    var pid = fact[&#x27;property&#x27;];
    var anns = fact[&#x27;annotations&#x27;] || [];
    if( sid &amp;amp;&amp;amp; oid &amp;amp;&amp;amp; pid ){

	new_edge = anchor.create_edge(sid, oid, pid);
	if( ! us.isArray(anns) ){
	    throw new Error(&#x27;annotations is wrong&#x27;);
	}else{
	    // Add the annotations individually.
	    each(anns, function(ann_kv_set){
		var na = new annotation(ann_kv_set);
		new_edge.add_annotation(na);
	    });
	}

	// Add and ready to return edge.
	anchor.add_edge(new_edge);
    }
    
    return new_edge;
};

/**
 * Return an edge ID by it&#x27;s associated connector ID if extant.
 *
 * @param {String} cid - the ID of the connector.
 * @returns {String} - the ID of the associated edge
 */
noctua_graph.prototype.get_edge_id_by_connector_id = function(cid){
    return this.core[&#x27;connector2edge&#x27;][cid] || null;
};

/**
 * Return a connector by it&#x27;s associated edge ID if extant.
 *
 * @param {String} eid - the ID of the edge
 * @returns {String} - the connector ID
 */
noctua_graph.prototype.get_connector_id_by_edge_id = function(eid){
    return this.core[&#x27;edge2connector&#x27;][eid] || null;
};

/**
 * Remove an edge to the graph.
 * The edge as referenced.
 *
 * @param {String} subject_id - subject by ID
 * @param {String} object_id - object by ID
 * @param {String} predicate_id - (Optional) predicate ID or default
 * @returns {Boolean} true if such an edge was found and deleted, false otherwise
 */
// noctua_graph.prototype.remove_edge = function(subject_id, object_id, predicate_id){
//     var ret = false;

//     var eedge = this.get_edge(subject_id, object_id, predicate_id);
//     if( eedge ){
// 	ret = this.remove_edge_by_id(eedge.id());
//     }

//     return ret;
// };

/**
 * Remove an edge to the graph.
 * The edge as IDed.
 *
 * @param {String} edge_id - edge by ID
 * @returns {Boolean} true if such an edge was found and deleted, false otherwise
 */
noctua_graph.prototype.remove_edge_by_id = function(eeid){
    var ret = false;

    if( this.core[&#x27;edges&#x27;][eeid] ){

	// Summon up the edge to properly remove it from the model.
	var eedge = this.core[&#x27;edges&#x27;][eeid];

	// Remove the node itself from super.
	ret = bbop_graph.prototype.remove_edge.call(eedge.subject_id(),
						    eedge.object_id(),
						    eedge.predicate_id());
	
	// Main bit out.
	delete this.core[&#x27;edges&#x27;][eeid];

	// And clean the maps.
	var cid = this.core[&#x27;edge2connector&#x27;][eeid];
	delete this.core[&#x27;edge2connector&#x27;][eeid];
	delete this.core[&#x27;connector2edge&#x27;][cid];
    }

    return ret;
};

/**
 * Internally connect an edge to a connector ID
 *
 * TODO/BUG: Should use generic ID mapping rather than depending on
 * jsPlumb thingamajunk.
 *
 * @deprecated
 * @param {edge} eedge - edge
 * @param {connector} connector - jsPlumb connector
 */
noctua_graph.prototype.create_edge_mapping = function(eedge, connector){
    var eid = eedge.id();
    var cid = connector.id;
    this.core[&#x27;edge2connector&#x27;][eid] = cid;
    this.core[&#x27;connector2edge&#x27;][cid] = eid;
};

/**
 * Debugging text output function.
 *
 * Not sure what this is for anymore honestly...
 *
 * @deprecated
 * @returns {String} a graph rep as a string
 */
noctua_graph.prototype.dump = function(){

    //
    var dcache = [];
    
    each(this.get_nodes(), function(node, node_id){	
	var ncache = [&#x27;node&#x27;];
	ncache.push(node.id());
	dcache.push(ncache.join(&quot;\t&quot;));
    });
    
    each(this.core[&#x27;edges&#x27;], function(edge, edge_id){
	var ecache = [&#x27;edge&#x27;];
	ecache.push(edge.subject_id());
	ecache.push(edge.predicate_id());
	ecache.push(edge.object_id());
	dcache.push(ecache.join(&quot;\t&quot;));
    });
    
    return dcache.join(&quot;\n&quot;);
};

/**
 * Load minerva data response.
 *
 * TODO: inferred individuals
 *
 * @param {Object} the &quot;data&quot; portion of a Minerva graph-related response.
 * @returns {Boolean} if data was loaded 
 */
noctua_graph.prototype.load_data_base = function(data){
    var anchor = this;

    var ret = false;

    if( data ){
	
	// Add the graph metadata.
	var graph_id = data[&#x27;id&#x27;] || null;
	var graph_anns = data[&#x27;annotations&#x27;] || [];
	if( graph_id ){ anchor.id(graph_id); }
	if( ! us.isEmpty(graph_anns) ){
	    each(graph_anns, function(ann_kv_set){
		var na = new annotation(ann_kv_set);
		anchor.add_annotation(na);
	    });
	}
	
	// Easy facts.
	var facts = data[&#x27;facts&#x27;];
	each(facts, function(fact){
	    anchor.add_edge_from_fact(fact);
	});

	// Build the structure of the graph in the most obvious way.
	var inds = data[&#x27;individuals&#x27;];
	//var i_inds = raw_resp[&#x27;data&#x27;][&#x27;individuals-i&#x27;];
	each(inds, function(ind){
	    anchor.add_node_from_individual(ind);
	});

	ret = true;
    }	

    return ret;
};

/**
 * Load minerva data response. However, this time, we&#x27;re going to fold
 * the evidence individuals into the edges and nodes that reference
 * them under the referenced_individual functions.
 *
 * TODO: inferred individuals
 *
 * @param {Object} the &quot;data&quot; portion of a Minerva graph-related response.
 * @returns {Boolean} if data was loaded 
 */
noctua_graph.prototype.load_data_fold_evidence = function(data){
    var anchor = this;

    var ret = false;

    if( data ){
	
	// Load the graph parts as usual.
	var graph_id = data[&#x27;id&#x27;] || null;
	var graph_anns = data[&#x27;annotations&#x27;] || [];
	if( graph_id ){ anchor.id(graph_id); }
	if( ! us.isEmpty(graph_anns) ){
	    each(graph_anns, function(ann_kv_set){
		var na = new annotation(ann_kv_set);
		anchor.add_annotation(na);
	    });
	}

	// Currently, evidence does not have edges, and if they did,
	// we wouldn&#x27;t want to handle them here. All edges in.
	var facts = data[&#x27;facts&#x27;];
	each(facts, function(fact){
	    anchor.add_edge_from_fact(fact);
	});

	// Start by adding all of the individuals to the graph.
	var inds = data[&#x27;individuals&#x27;];
	//var i_inds = raw_resp[&#x27;data&#x27;][&#x27;individuals-i&#x27;];
	each(inds, function(ind){
	    anchor.add_node_from_individual(ind);
	});

	// Find the evidence singletons and remove them from the
	// graph.
	var singletons = {};
	each(anchor.get_singleton_nodes(), function(singleton){
	    var sid = singleton.id();
	    singletons[sid] = singleton;
	    anchor.remove_node(sid);
	});

	//console.log(&#x27;singletons&#x27;);
	//console.log(singletons);

	// Add the evidence singletons back into the structure by
	// scanning through the nodes and adding them as referenced
	// individuals.
	each(anchor.all_nodes(), function(node){
	    each(node.annotations(), function(ann){

		//console.log(ann.key(), ann.value_type(), ann.value());
		
		// Is it an evidence annotation.
		if( ann.key() == &#x27;evidence&#x27; &amp;amp;&amp;amp; ann.value_type() == &#x27;IRI&#x27; ){
		    // If so, add it in.
		    var ev_ref = ann.value();
		    if( singletons[ev_ref] ){
			var ev_indiv = singletons[ev_ref];
			var c1 = node.add_referenced_individual(ev_indiv);
//			console.log(&#x27;&amp;lt;&amp;lt;&#x27; + node.id() + &#x27;&gt;1&gt;&#x27;, c1.length);
			var c2 = node.referenced_individuals();
//			console.log(&#x27;&amp;lt;&amp;lt;&#x27; + node.id() + &#x27;&gt;2&gt;&#x27;, c2.length);
//			console.log(node)
		    }
		}
	    });
	});

	// We also need to do the same thing with the edges, adding
	// back in the evidence as referenced individuals.
	each(anchor.all_edges(), function(edge){
	    each(edge.annotations(), function(ann){

		// Is it an evidence annotation.
		if( ann.key() == &#x27;evidence&#x27; &amp;amp;&amp;amp; ann.value_type() == &#x27;IRI&#x27; ){
		    // If so, add it in.
		    var ev_ref = ann.value();
		    if( singletons[ev_ref] ){
			var ev_indiv = singletons[ev_ref];
			edge.add_referenced_individual(ev_indiv);
		    }
		}
	    });
	});

	ret = true;
    }	

//    console.log(anchor);

    return ret;
};

///
/// Node subclass and overrides.
///

var bbop_node = bbop_model.node;
/**
 * Sublcass of bbop-graph.node for use with Noctua ideas and concepts.
 *
 * @constructor
 * @see module:bbop-graph
 * @alias node
 * @param {String} in_id - (optional) new id; otherwise new unique generated
 * @param {String} in_label - (optional) node &quot;label&quot;
 * @param {Array} in_types - (optional) list of Objects or strings--anything that can be parsed by class_expression
 * @returns {this}
 */
function noctua_node(in_id, in_label, in_types){
    bbop_node.call(this, in_id, in_label);
    this._is_a = &#x27;bbop-graph-noctua.node&#x27;;
    var anchor = this;

    this._types = [];
    this._id2type = {};
    this._annotations = [];
    this._referenced_individuals = [];

    // Incoming ID or generate ourselves.
    if( typeof(in_id) === &#x27;undefined&#x27; ){
	this._id = bbop.uuid();
    }else{
	//this._id = in_id;
	this._id = in_id;
    }

    // Roll in any types that we may have coming in.
    if( us.isArray(in_types) ){
	each(in_types, function(in_type){
	    var new_type = new class_expression(in_type);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new class_expression(in_type));
	});
    }
    
    // Optional layout hints.
    this._x_init = null; // initial layout hint
    this._y_init = null;
    // this.xlast = null; // last known location
    // this.ylast = null;
};
bbop.extend(noctua_node, bbop_node);

/**
 * Get a fresh new copy of the current node (using bbop.clone for
 * metadata object).
 *
 * @returns {node} node
 */
noctua_node.prototype.clone = function(){
    var anchor = this;

    // Fresh.
    var new_clone = new noctua_node(anchor.id(), anchor.label(), anchor.types());

    // Base class stuff.
    new_clone.type(this.type());
    new_clone.metadata(bbop.clone(this.metadata()));

    // Transfer over the new goodies.
    each(anchor._annotations, function(annotation){
	new_clone._annotations.push(annotation.clone());
    });
    each(anchor._referenced_individuals, function(ind){
	new_clone._referenced_individuals.push(ind.clone());
    });
    new_clone._x_init = anchor._x_init;
    new_clone._y_init = anchor._y_init;

    return new_clone;
};

/**
 * Get current types; replace current types.
 * 
 * Parameters:
 * @param {Array} in_types - (optional) raw JSON type objects
 * @returns {Array} array of types
 */
noctua_node.prototype.types = function(in_types){
    var anchor = this;    

    if( us.isArray(in_types) ){

	// Wipe previous type set.
	anchor._id2type = {};
	anchor._types = [];

	each(in_types, function(in_type){
	    var new_type = new class_expression(in_type);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new_type);
	});
    }
    return this._types;
};

/**
 * Add types to current types.
 * 
 * Parameters:
 * @param {Object} in_types - raw JSON type objects
 * @param {Boolean} inferred_p - whether or not the argument types are inferred
 * @returns {Boolean} t|f
 */
noctua_node.prototype.add_types = function(in_types, inferred_p){
    var anchor = this;    
    var inf_p = inferred_p || false;

    var ret = false;

    if( us.isArray(in_types) ){
	each(in_types, function(in_type){
	    var new_type = new class_expression(in_type, inf_p);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new_type);
	    
	    ret = true; // return true if did something
	});
    }
    return ret;
};

/**
 * If extant, get the type by its unique identifier.
 * 
 * @param {String} type_id - type id
 * @returns {type|null} type or null
 */
noctua_node.prototype.get_type_by_id = function(type_id){
    var anchor = this;

    var ret = null;
    ret = anchor._id2type[type_id];

    return ret;
};

/**
 * Get/set &quot;x&quot; value of node.
 * 
 * @param {Number} value - number
 * @returns {Number|null} type or null
 */
noctua_node.prototype.x_init = function(value){
    if(value) this._x_init = value;
    return this._x_init;
};

/**
 * Get/set &quot;y&quot; value of node.
 * 
 * @param {Number} value - number
 * @returns {Number|null} type or null
 */
noctua_node.prototype.y_init = function(value){
    if(value) this._y_init = value;
    return this._y_init;
};

///
/// Edge subclass and overrides.
///

var bbop_edge = bbop_model.edge;
/**
 * Sublcass of bbop-graph.edge for use with Noctua ideas and concepts.
 *
 * @constructor
 * @see module:bbop-graph
 * @alias edge
 * @param {String} subject - required subject id
 * @param {String} object - required object id
 * @param {String} predicate - (optional) preidcate id; if not provided, will use defined default (you probably want to provide one--explicit is better)
 * @returns {this}
 */
function noctua_edge(subject, object, predicate){
    bbop_edge.call(this, subject, object, predicate);
    this._is_a = &#x27;bbop-graph-noctua.edge&#x27;;

    // Edges are not completely anonymous in this world.
    this._id = bbop.uuid();

    this._annotations = [];
    this._referenced_individuals = [];
};
bbop.extend(noctua_edge, bbop_edge);

/**
 * Get a fresh new copy of the current edge--no shared structure.
 *
 * @returns {edge} - new copy of edge
 */
noctua_edge.prototype.clone = function(){
    var anchor = this;

    // Fresh.
    var new_clone = new noctua_edge(anchor.subject_id(),
				    anchor.object_id(),
				    anchor.predicate_id());

    // Same id.
    new_clone._id = anchor._id;
    
    // Base class stuff.
    new_clone.default_predicate = anchor.default_predicate;
    new_clone.type(anchor.type());
    new_clone.metadata(bbop.clone(anchor.metadata()));

    // Transfer over the new goodies.
    each(anchor._annotations, function(annotation){
	new_clone._annotations.push(annotation.clone());
    });
    each(anchor._referenced_individuals, function(ind){
	new_clone._referenced_individuals.push(ind.clone());
    });

    return new_clone;
};

/**
 * Access to the &quot;id&quot;.
 * 
 * @returns {String} string
 */
noctua_edge.prototype.id = function(){
    return this._id;
 };

/**
 * Get/set &quot;source&quot; of edge.
 * 
 * @deprecated
 * @param {String} value - (optional) string
 * @returns {String} string
 */
noctua_edge.prototype.source = function(value){
    if(value) this._subject_id = value;
    return this._subject_id;
};

/**
 * Get/set &quot;target&quot; of edge.
 * 
 * @deprecated
 * @param {String} value - (optional) string
 * @returns {String} string
 */
noctua_edge.prototype.target = function(value){
    if(value) this._object_id = value;
    return this._object_id;
};

/**
 * Get/set &quot;relation&quot; of edge.
 * 
 * @deprecated
 * @param {String} value - (optional) string
 * @returns {String} string
 */
noctua_edge.prototype.relation = function(value){
    if(value) this._predicate_id = value;
    return this._predicate_id;
};

// Add generic bulk annotation operations to: graph, edge, and node.
each([noctua_graph, noctua_node, noctua_edge], function(constructr){
    constructr.prototype.annotations = _annotations;
    constructr.prototype.add_annotation = _add_annotation;
    constructr.prototype.get_annotations_by_filter = _get_annotations_by_filter;
    constructr.prototype.get_annotations_by_key = _get_annotations_by_key;
    constructr.prototype.get_annotation_by_id = _get_annotation_by_id;
});

// Add generic evidence (referenced individuals) operations to: edge
// and node.
each([noctua_node, noctua_edge], function(constructr){
    constructr.prototype.referenced_individuals =
	_referenced_individuals;
    constructr.prototype.add_referenced_individual =
	_add_referenced_individual;
    constructr.prototype.get_referenced_individuals_by_filter =
	_get_annotations_by_filter;
    constructr.prototype.get_referenced_individual_by_id =
	_get_referenced_individual_by_id;
    constructr.prototype.get_referenced_individual_profiles
	= _get_referenced_individual_profiles;
    constructr.prototype.get_basic_evidence
	= _get_basic_evidence;
});

///
/// Exportable body.
///

module.exports = {

    annotation: annotation,
    node: noctua_node,
    edge: noctua_edge,
    graph: noctua_graph

};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on June 7, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>